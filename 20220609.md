# 1. Given an integer array nums, return the length of the longest strictly increasing subsequence https://leetcode.com/problems/longest-increasing-subsequence/

Solution

- DP: O(n^2) & S(n) 
- Patience Sorting https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf: O(nlogn) & S(n)

Code

- Java

```java

```

- Python 1 (DP)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        length_list = [1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    length_list[i] = max(length_list[j]+1, length_list[i])
        return max(length_list)
```

- Python 2 (Patience Sorting)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        sub = []
        
        def binary_search(sub, val):
            start = 0
            end = len(sub)-1
            while start <= end:
                mid = (start+end)//2
                if val > sub[mid]:
                    start = mid + 1
                else:
                    end = mid - 1
            return start
        
        for i in range(len(nums)):
            if len(sub) == 0 or nums[i] > sub[-1]:
                sub.append(nums[i])
            else:
                idx = binary_search(sub, nums[i])
                sub[idx] = nums[i]
                
        return len(sub)
```

# 2. Find the insert position of a integer into sorted array https://leetcode.com/problems/search-insert-position/

Solution

- Binary search: O(logn) & S(1)

Code

- Java

```java

```

- Python

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        start = 0
        end = len(nums)-1
        while start <= end:
            mid = (start + end) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                end = mid - 1
            elif nums[mid] < target:
                start = mid + 1
        return start
```


# 3. Return the minimum number of intervals needed to be removed so that the others are non-overlapping https://leetcode.com/problems/non-overlapping-intervals/

Solution

- Sort by the start and then sort by the end, remove intervals that overlap with the former one

Code

- Java

```java

```

- Python

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        sorted_intervals = sorted(intervals)
        cur = sorted_intervals[0]
        count = 1
        for i in range(len(sorted_intervals)):
            if sorted_intervals[i][0] < cur[1]:
                cur[1] = min(sorted_intervals[i][1], cur[1])
            else:
                cur[1] = max(sorted_intervals[i][1], cur[1])
                count += 1
        return len(sorted_intervals)-count
```